package org.rti.ttfinder.wrapper;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.Environment;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import com.opencsv.CSVReaderHeaderAware;
import com.opencsv.CSVWriter;
import com.opencsv.exceptions.CsvValidationException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.rti.ttfinder.R;
import org.rti.ttfinder.models.ProcessedImageResult;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.*;

import org.rti.ttfinder.models.ProcessedImageResult;
import org.tensorflow.lite.TensorFlowLite;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class TTProcessorTest {

    private TTProcessor imageProcessor;
    private final static boolean CREATE_DEBUG_IMAGES = false;
    private final static boolean RUN_TEST_FULLTESTSET = false;

    private void setupProcessor(boolean featureExtStep) {
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        String outputDir = "TTScreenerMLAppLogs_Test";
        imageProcessor = null;
        String root;
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.R){
            root = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS).toString();
        }
        else{
            root = Environment.getExternalStorageDirectory().toString();
        }
        File myDir = new File(root + "/"+ appContext.getResources().getString(R.string.folder_name)+"/"+outputDir);
        myDir.mkdirs();
        try {
            imageProcessor = new TTProcessor(myDir, appContext, featureExtStep);
        }
        catch(Exception e) {
            Log.e("MAIN", "Error while setting up image processor : \n" + e);
        }
    }

    private Bitmap loadBitmap(int resource, Context context) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inPreferredConfig = Bitmap.Config.ARGB_8888;
        options.inSampleSize = 2;
        return BitmapFactory.decodeResource(context.getResources(), resource, options);
    }

    private Bitmap loadBitmapFromFile(String filePath) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inPreferredConfig = Bitmap.Config.ARGB_8888;
        return BitmapFactory.decodeFile(filePath, options);
    }

    private Bitmap cropImage(final Bitmap mBitmapIn) {
        int mPhotoWidth = mBitmapIn.getWidth();
        int mPhotoHeight = mBitmapIn.getHeight();
        Log.v("MAINProcessImage", "Original image dimensions : " + mPhotoWidth + "," + mPhotoHeight);

        int ycrop = 0, xcrop=0, targetWidth = 0;
        if(mPhotoHeight >= mPhotoWidth) {
            ycrop = (mPhotoHeight - mPhotoWidth) / 2;
            targetWidth = mPhotoWidth;
        }
        else {
            xcrop = (mPhotoWidth - mPhotoHeight)/2;
            targetWidth = mPhotoHeight;
        }
        Bitmap nBitmap = Bitmap.createBitmap(mBitmapIn, xcrop, ycrop, targetWidth, targetWidth);

        mPhotoWidth = nBitmap.getWidth();
        mPhotoHeight = nBitmap.getHeight();
        Log.v("MAINProcessImage", "After crop: " + mPhotoWidth + "," + mPhotoHeight);
        return nBitmap;
    }

    @Test
    public void testRunFullTestSet(){
        /*
        * This test will run the processor on a set of images pointed to by the
        * csv in testfile variable below.
        *
        * The csv should at least have two columns: img, class
        * img: path to the image with extension
        * class: 0 or 1 (0 = Healthy, 1 = TT)
        *
        * The images should be copied to TrachomaTestSet alongside the TTScreener folder
        * The csv should also be in this folder.
        *
        * Hina has a separate script (read_phone_testlogs.py) to read the log files generated by all the files
        *
        * To run the full test set enable RUN_TEST_FULLTESTSET in class variables
        *
        * By default this test will skip any existing images. Please delete the TTScreenerMLAppsLogs_Test
        * folder if this is not the behaviour you want
        *
        * */
        if (RUN_TEST_FULLTESTSET){

            setupProcessor(true);

            // Find images on the phone
            String root;
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.R){
                root = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS).toString();
            }
            else{
                root = Environment.getExternalStorageDirectory().toString();
            }

            File myDir = new File(root + "/TrachomaTestSet");
            Log.v("TEST", "Storing at: " + myDir);
            //Load the csv with original test set, and get the original classes
            Map<String, String> ground_truth = new HashMap<>();
            File testFile = new File(myDir, "trachoma_bsl_mtss_besrat_field_test_202208_orig_subset.csv");
            try {
                CSVReaderHeaderAware csvRead = new CSVReaderHeaderAware(new FileReader(testFile));
                Map<String, String> map = csvRead.readMap();
                while( map != null ){
                    String im = map.get("image");
                    String imname = new File(map.get("image")).getName();
                    String result = "TT";
                    if(map.get("class").equals("0"))
                        result = "Healthy";
                    ground_truth.put(imname, result);
                    map = csvRead.readMap();
                }
            }
            catch(FileNotFoundException e){
                Log.e("TEST", "Threw a file not found exception");
                assertTrue(testFile.exists());
            }
            catch(IOException e){
                Log.e("TEST", "Error in loading the CSV file");
            }
            catch(CsvValidationException e){
                Log.e("TEST", "Error parsing the csv");
            }

            String[] imageList = myDir.list();
            // Load image one by one
            assertNotNull(imageProcessor);
            assertTrue(imageList.length > 0);

            // Run the test, and write to a CSVCSVWriter csvWrite = new CSVWriter(new FileWriter(file));
            String[] header = {"tt_id","ground_truth", "phone_pred", "weight", "runtime_ms"};
            List<String[]> assessmentList = new ArrayList<>();
            assessmentList.add(header);

            int cnt= 0;
            for(String imageName : ground_truth.keySet()){
                Log.v("TEST", "-------- PROCESSING IMAGE: no: " + cnt + " :: " + imageName + " --------");
                cnt+=1;
//                if(cnt==10){
//                    break;
//                }
                if(!imageName.endsWith(".jpg"))
                    continue;
                File imagedDir = new File(imageProcessor.getOutputDirectoryPath(), imageName.substring(0, imageName.lastIndexOf('.')));
                Log.v("TEST", "Looking for: " + imagedDir);
                if (imagedDir.exists()) {
                    Log.v("TEST", "Directory " + imagedDir + " already exists, skipping");
                    // TODO: read an existing log file and create the assessment string
                    continue;
                }
                String filePath = myDir+ "/" + imageName;
                Bitmap m_img = loadBitmapFromFile(filePath);
                assertNotNull(m_img);
                try {
                    imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                    ProcessedImageResult result = imageProcessor.processImage(m_img, imageName.substring(0, imageName.lastIndexOf('.')));
                    boolean success = result.isSuccess();
                    if (!success){
                        String[] assessment = {imageName,
                                ground_truth.get(imageName),
                                "FAILED",
                                "-1",
                                "-1"
                        };
                        assessmentList.add(assessment);
                    }
                    else {
                        String[] r = imageProcessor.getLastClassificationResult().split("::");
                        String[] assessment = {imageName,
                                ground_truth.get(imageName),
                                r[0].trim(),
                                r[1].trim(),
                                String.valueOf(imageProcessor.getLastPipelineTimeCost() / 1000.)
                        };
                        assessmentList.add(assessment);
                    }
                }
                catch(IOException e){
                    Log.e("MAIN", "Error processing");
                }
            }
            Log.v("TEST", "Processed " + cnt + " images");
            myDir = new File(root + "/TTScreener/");
            myDir.mkdirs();
            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String fname = "TrachomaTestSetAssessment-" + timeStamp + ".csv";
            File file = new File(myDir, fname);
            try {
                CSVWriter csvWrite = new CSVWriter(new FileWriter(file));
                csvWrite.writeAll(assessmentList);
                csvWrite.close();
            }
            catch(IOException e){
                Log.e("TEST","Error writing out the CSV file");
            }
        }
    }

    @Test
    public void testRunPipelineTT() {
        Bitmap m_img = loadBitmap(R.drawable.misclassified, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result  = imageProcessor.processImage(cropped, "misclassified");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "TT";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineTT1() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev1, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_im_sev1");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "TT";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineTT2() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev2, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped  = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_im_sev2");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "TT";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineTT3() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev3, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped  = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_im_sev3");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "TT";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }


    @Test
    public void testRunPipelineHealthy() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev0, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped  = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_image_sev0");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "Healthy";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineHealthy1() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev0_1, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped  = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_im_healthy1");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "Healthy";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineHealthySegmentation() {
        Bitmap m_img = loadBitmap(R.drawable.test_image_sev0, InstrumentationRegistry.getInstrumentation().getTargetContext());
        Bitmap cropped  = cropImage(m_img);
        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(cropped, "test_image_sev0", true);
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, true);
        String trueLabel = "";
        if(success == true){
            String result = imageProcessor.getLastClassificationResult();
            Log.v("MAIN", result);
            assertEquals(result.contains(trueLabel), true);
        }
    }

    @Test
    public void testRunPipelineB() {
        Bitmap m_img = loadBitmap(R.drawable.test_image, InstrumentationRegistry.getInstrumentation().getTargetContext());

        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(m_img, "test_im");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, false);
    }

    @Test
    public void testRunPipelineA() {
        Bitmap m_img = loadBitmap(R.drawable.data, InstrumentationRegistry.getInstrumentation().getTargetContext());

        boolean success = false;
        setupProcessor(true);
        if (imageProcessor != null) {
            try {
                imageProcessor.setCreateDebugImages(CREATE_DEBUG_IMAGES);
                ProcessedImageResult result = imageProcessor.processImage(m_img, "test_im");
                success = result.isSuccess();
            }
            catch(IOException e){
                Log.e("MAIN", "Error processing");
            }
        }
        assertEquals(success, false);
    }

    @Test
    public void testProcessorSetupWithFeatureExtStep() {

        Log.v("MAIN", "Version of tensorflow is: " + TensorFlowLite.runtimeVersion());
        Log.v("MAIN", "Version of tensorflow is: " + TensorFlowLite.schemaVersion());
        setupProcessor(true);
        assertNotEquals(imageProcessor, null);
    }

    @Test
    public void testProcessorSetupWithoutFeatureExtStep() {

        Log.v("MAIN", "Version of tensorflow is: " + TensorFlowLite.runtimeVersion());
        Log.v("MAIN", "Version of tensorflow is: " + TensorFlowLite.schemaVersion());

        setupProcessor(false);
        assertNotEquals(imageProcessor, null);
    }

    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
        assertEquals("org.rti.ttfinder", appContext.getPackageName());
    }
}